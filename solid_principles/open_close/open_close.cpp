#include <iostream>
#include <cstdio>
#include <string>
#include <vector>
#include <fstream>
#include <boost/lexical_cast.hpp>

using namespace std;
using namespace boost;

/*
Example: 
We have a web shop an want to filter by products by their attributes
*/

// definition of attributes
enum class Color {
	red,
	green,
	blue
};

enum class Size {
	small,
	middle,
	large
};

// product class itself
struct Product {
	std::string _name;
	Color _color;
	Size _size;
};

// single responsabilit - filter class

// The following is a bad idea because we modify already implemented (and maybe tested) code
// We need to re-read it and do our modification to the class. This contradicts the open close principle
/*
struct ProductFilter {
	std::vector <Product*> by_color(std::vector<Product*>& products, Color color) {
		std::vector<Product*> result;
		for (auto& it : products) {
			if (it->_color == color) {
				result.push_back(it);
			}
		}
		return result;
	}

	std::vector <Product*> by_size(std::vector<Product*>& products, Size size) {
		std::vector<Product*> result;
		for (auto& it : products) {
			if (it->_size == size) {
				result.push_back(it);
			}
		}
		return result;
	}

	std::vector <Product*> by_size_and_color(std::vector<Product*>& products, Size size, Color color) {
		std::vector<Product*> result;
		for (auto& it : products) {
			if ( (it->_size == size) && (it->_color == color) ) {
				result.push_back(it);
			}
		}
		return result;
	}
};
*/

// Better (corresponding to the open close principle): specification pattern
template <typename T> struct AndSpecification; // forward declaration in order to define the operator&& for Specification

template <typename T>
struct Specification { // interface for the specification that a filter need to use - here we have the definition how a programmer should implement its own specifiaction to filter for
	virtual bool is_satisfied(T* item) = 0; // needed to have a generic possability to check whether a spec is satisfied on an item within the filter
	
	AndSpecification<T> operator&&(Specification<T>&& other) {
		return AndSpecification<T>(*this, other);
	}
};

template <typename T>
struct Filter { // interface how we can implement our own filters
	virtual std::vector<T*> filter(std::vector<T*> items, Specification<T>& spec) = 0;
};

// implementing a concrete filter class/struct
struct GenericSingleFilter : public Filter<Product> {
	std::vector<Product*> filter(std::vector<Product*> items, Specification<Product>& spec) {
		std::vector<Product*> result;
		for (auto& it : items) {
			if (spec.is_satisfied(it)) {
				result.push_back(it);
			}
		}
		return result;
	}
};

// implementing a specification to filter for (based on the outcommented example before)
struct ColorSpec : public Specification<Product> {
	// members
	Color _color;
	
	// constructor
	ColorSpec(Color color) : _color(color) {}
	
	// methods
	bool is_satisfied(Product* item) override {
		if (item->_color == _color) {
			return true;
		}
		else {
			return false;
		}
	}
};

struct SizeSpec : public Specification<Product> {
	// members
	Size _size;

	// constructor
	SizeSpec(Size size) : _size(size) {}

	// methods
	bool is_satisfied(Product* item) override {
		if (item->_size == _size) {
			return true;
		}
		else {
			return false;
		}
	}
};

// Implementation of a type agnostic combinator of the AndSpecification as a specific expression of Specification
template <typename T>
struct AndSpecification : public Specification<T> { // The actual code is completly generated by the compiler
	Specification<T>& _firstSpec;
	Specification<T>& _secSpec;

	// CAUTION: This is NOT an abstract base class
	AndSpecification(Specification<T>& first, Specification<T>& sec) :
		_firstSpec(first),
		_secSpec(sec) {}

	bool is_satisfied(T* item) override {
		if (_firstSpec.is_satisfied(item) && _secSpec.is_satisfied(item))
			return true;
		return false;
	}
};

template <typename T>
struct OrSpecification : public Specification<T> { // The actual code is completly generated by the compiler
	Specification<T>& _firstSpec;
	Specification<T>& _secSpec;

	// CAUTION: This is NOT an abstract base class
	OrSpecification(Specification<T>& first, Specification<T>& sec) :
		_firstSpec(first),
		_secSpec(sec) {}

	bool is_satisfied(T* item) override {
		if (_firstSpec.is_satisfied(item) || _secSpec.is_satisfied(item))
			return true;
		return false;
	}
};
/*
Since the AndSpecification and OrSpecification takes other specifications as their constructor arguments, we are able to stack multiple specifications on top of each other without writing new code within the actual implementations - we can extend our code without modifing it (which is the idea of the open-close principle)
*/


int main()
{
	Product apple{"Apple", Color::green, Size::small}; // structs can be initalized by the order of the member definitions from top to bottom
	Product tree{"Tree", Color::green, Size::large};
	Product house{ "House", Color::blue, Size::large };
	std::vector<Product*> items{ &apple, &tree, &house };

	/*
	ProductFilter filter; // no constructor arguments needed
	std::vector<Product*> greenProducts = filter.by_color(items, Color::green);
	*/

	// example with the specification pattern
	GenericSingleFilter genFilter;
	ColorSpec colorSpec(Color::green);
	SizeSpec sizeSpec(Size::small);

	// filter by color
	std::vector<Product*> greenProducts = genFilter.filter(items, colorSpec);
	std::cout << "The green products are:" << std::endl;
	for (auto& prod : greenProducts) {
		std::cout << prod->_name << std::endl;
	}
	std::cout << "Finished filtering by color" << std::endl;

	// filter by size
	std::vector<Product*> smallProducts = genFilter.filter(items, sizeSpec);
	std::cout << "The small products are:" << std::endl;
	for (auto& prod : smallProducts) {
		std::cout << prod->_name << std::endl;
	}
	std::cout << "Finished filtering by size" << std::endl;

	// combinator example
	AndSpecification<Product> greenAndSmallSpec(sizeSpec, colorSpec); // The template argument <Product> tells the compiler which code it should generate to make the AND combinator work
	std::vector<Product*> greenAndSmall = genFilter.filter(items, greenAndSmallSpec);
	std::cout << "green and small products are:" << std::endl;
	for (auto& it : greenAndSmall) {
		std::cout << it->_name << std::endl;
	}
	std::cout << "Finished green and small products" << std::endl;

	OrSpecification<Product> greenOrSmallSpec(sizeSpec, colorSpec); // The template argument <Product> tells the compiler which code it should generate to make the AND combinator work
	std::vector<Product*> greenOrSmall = genFilter.filter(items, greenOrSmallSpec);
	std::cout << "green or small products are:" << std::endl;
	for (auto& it : greenOrSmall) {
		std::cout << it->_name << std::endl;
	}
	std::cout << "Finished green or small products" << std::endl;

	// example of stacking the specifications
	ColorSpec blueSpec(Color::blue);
	OrSpecification blueOrGreenAndSmallSpec(blueSpec, greenAndSmallSpec);
	std::vector<Product*> blueOrGreenAndSmall = genFilter.filter(items, blueOrGreenAndSmallSpec);
	std::cout << "Blue or Green and Small is:" << std::endl;
	for (auto& it : blueOrGreenAndSmall)
		std::cout << it->_name << std::endl;
	std::cout << "Finished filtering for blue or green and small" << std::endl;

	// and operator example
	AndSpecification blueAndLargeSpec = ColorSpec(Color::blue) && SizeSpec(Size::large);
	std::vector<Product*> blueAndLarge = genFilter.filter(items, blueAndLargeSpec);
	std::cout << "The following items are blue and large:" << std::endl;
	for (auto& it : blueAndLarge)
		std::cout << it->_name << std::endl;
	std::cout << "Finished filtering by blue and large" << std::endl;

	return 0;
}